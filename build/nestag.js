// Generated by CoffeeScript 1.9.2
/*! Nestag 0.0.9 //// MIT Licence //// http://nestag.richplastow.com/ */
(function(global) {

/* Define the Oopish container. 
Rather than just a generic object, the Oopish container can also be used as 
a handy shortcut for console.log(). Note bind() (http://goo.gl/66ffgl), and 
unusual IE8-9 behaviour (http://goo.gl/ZmG9Xs). */
var oo = (function (c) { return (
(!c || !c.log) // IE8-9 without F12 dev-tools, IE6-7, FF1-3.6
? function () {}
: ("object" === typeof c.log) // IE8-9 with F12 dev-tools
? function () { c.log([].slice.call(arguments).join(" ")) }
: (! Function.prototype.bind) // OP10.6-11.5, SF4-5.0, iOS3-5.1, ADRD2.1-3.0?
? function () { c.log.apply(c, arguments) }
: c.log.bind(c)
)}(global.console));

/* Define constants generated by oopish-build and injected into app-scope. */
oo.G = global // global scope, passed into the closure as an argument
oo.T = "Nestag" // project title, from package.json
oo.V = "0.0.9" // project version, from package.json


/*! Nestag 0.0.9 */
var COORD_RULE, Location, Nestag, TAG_RULE, drawBorder, drawBox, global_tags;

oo.A = 'array';

oo.B = 'boolean';

oo.D = 'document';

oo.E = 'error';

oo.F = 'function';

oo.I = 'integer';

oo.N = 'number';

oo.O = 'object';

oo.R = 'regexp';

oo.S = 'string';

oo.U = 'undefined';

oo.X = 'null';

oo._ = (Math.random().toString(36) + '00000000').substr(2, 8);

oo.ROBUSTABLE = (function() {
  if (!Object.preventExtensions) {
    return false;
  } else if (Object.defineProperty) {
    try {
      Object.defineProperty({}, 'x', {});
      return true;
    } catch (_error) {
      return false;
    }
  } else {
    return true;
  }
})();

oo.is = function(c, t, f) {
  if (t == null) {
    t = true;
  }
  if (f == null) {
    f = false;
  }
  if (c) {
    return t;
  } else {
    return f;
  }
};

oo.isU = function(x) {
  return oo.U === typeof x;
};

oo.isX = function(x) {
  return null === x;
};

oo.type = function(a) {
  var ta;
  if (oo.isX(a)) {
    return oo.X;
  }
  ta = typeof a;
  if ({
    undefined: 1,
    string: 1,
    number: 1,
    boolean: 1
  }[ta]) {
    return ta;
  }
  if (!a.nodeName && a.constructor !== Array && /function/i.test('' + a)) {
    return oo.F;
  }
  return {}.toString.call(a).match(/\s([a-z0-9]+)/i)[1].toLowerCase();
};

oo.ex = function(x, a, b) {
  var pos;
  if (-1 === (pos = a.indexOf(x))) {
    return x;
  } else {
    return b.charAt(pos);
  }
};

oo.has = function(h, n, t, f) {
  if (t == null) {
    t = true;
  }
  if (f == null) {
    f = false;
  }
  if (-1 !== h.indexOf(n)) {
    return t;
  } else {
    return f;
  }
};

oo.uid = function(p) {
  if (p == null) {
    p = 'id';
  }
  return p + '_' + (Math.random().toString(36) + '00000000').substr(2, 8);
};

oo.uid62 = function(p, l) {
  var c;
  if (p == null) {
    p = 'id';
  }
  if (l == null) {
    l = 8;
  }
  c = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
  return p + '_' + ((function() {
    var results;
    results = [];
    while (l--) {
      results.push(c.charAt(Math.floor(Math.random() * 62)));
    }
    return results;
  })()).join('');
};

oo.lpad = function(s, l, c) {
  if (c == null) {
    c = ' ';
  }
  return Array(l - s.length + 1).join(c) + s;
};

oo.rpad = function(s, l, c) {
  if (c == null) {
    c = ' ';
  }
  return s + Array(l - s.length + 1).join(c);
};

oo.insert = function(basis, overlay, offset) {
  return basis.slice(0, offset) + overlay + basis.slice(offset + overlay.length);
};

if (oo.ROBUSTABLE) {
  oo.define = function(obj, name, value, kind) {
    switch (kind) {
      case 'constant':
        return Object.defineProperty(obj, name, {
          value: value,
          enumerable: true
        });
      case 'private':
        return Object.defineProperty(obj, name, {
          value: value,
          enumerable: false
        });
    }
  };
} else {
  oo.define = function(obj, name, value, kind) {
    return obj[name] = value;
  };
}

if (oo.ROBUSTABLE) {
  oo.lock = function(obj) {
    var k, key, len, ref;
    ref = Object.keys(obj);
    for (k = 0, len = ref.length; k < len; k++) {
      key = ref[k];
      Object.defineProperty(obj, key, {
        writable: false,
        configurable: false
      });
    }
    Object.preventExtensions(obj);
    if (obj.prototype && obj !== obj.prototype) {
      return oo.lock(obj.prototype);
    }
  };
} else {
  oo.lock = function() {};
}

oo.vArray = function(M, arr, signature, fallback) {
  var i, k, len, len1, limit, m, matches, max, min, pass, ref, ref1, ref2, rule, tv, type, types, value;
  matches = signature.match(/^<\[([|a-z]+)\s*(.*)\](\d+-\d+)?>$/i);
  if (!matches) {
    throw RangeError("/nestag/oopish/oo-helpers.litcoffee oo.vArray()\n  signature " + signature + " is invalid");
  }
  signature = matches[0], types = matches[1], rule = matches[2], limit = matches[3];
  if (!arr) {
    return fallback;
  }
  if (oo.A !== oo.type(arr)) {
    throw RangeError(M + (" is type " + (oo.type(arr)) + " not array"));
  }
  if (limit) {
    ref = limit.split('-'), min = ref[0], max = ref[1];
    if (arr.length < min || arr.length > max) {
      throw RangeError(M + (".length is " + arr.length + " (must be " + limit + ")"));
    }
  }
  if ('any' === types) {
    return arr;
  }
  for (i = k = 0, len = arr.length; k < len; i = ++k) {
    value = arr[i];
    tv = oo.type(value);
    pass = false;
    ref1 = types.split('|');
    for (m = 0, len1 = ref1.length; m < len1; m++) {
      type = ref1[m];
      if ((oo.N === type || oo.I === type) && oo.N === tv) {
        if (oo.I === type && value % 1) {
          throw RangeError(M + ("[" + i + "] is a number but not an integer"));
        }
        if (rule) {
          ref2 = rule.split('-'), min = ref2[0], max = ref2[1];
          if (value < min || value > max) {
            throw RangeError(M + ("[" + i + "] is " + value + " (must be " + rule + ")"));
          }
        }
        pass = true;
        break;
      }
      if (type === tv) {
        if (oo.S === tv && rule) {
          if (!RegExp(rule).test(value)) {
            throw RangeError(M + ("[" + i + "] fails " + rule));
          }
        }
        pass = true;
        break;
      }
      if (/^[A-Z]/.test(type)) {
        if (oo.O === tv) {
          if (eval("value instanceof " + type)) {
            pass = true;
            break;
          }
        }
      }
    }
    if (pass) {
      continue;
    }
    throw TypeError(M + ("[" + i + "] is type " + tv + " not " + types));
  }
  return arr;
};

oo.vArg = function(M, value, signature, fallback) {
  var k, key, len, matches, max, min, pfx, ref, ref1, rule, tv, type, types;
  matches = signature.match(/^([_a-z][_a-z0-9]*)\s+<([|a-z]+)\s*(.*)>$/i);
  if (!matches) {
    throw RangeError("/nestag/oopish/oo-helpers.litcoffee oo.vArg()\n  signature " + signature + " is invalid");
  }
  signature = matches[0], key = matches[1], types = matches[2], rule = matches[3];
  pfx = M + ("argument " + key + " ");
  tv = oo.type(value);
  if (oo.U === tv) {
    if (4 === arguments.length) {
      return fallback;
    }
    throw TypeError(pfx + "is undefined and has no fallback");
  }
  ref = types.split('|');
  for (k = 0, len = ref.length; k < len; k++) {
    type = ref[k];
    if ((oo.N === type || oo.I === type) && oo.N === tv) {
      if (oo.I === type && value % 1) {
        throw RangeError(pfx + "is a number but not an integer");
      }
      if (rule) {
        ref1 = rule.split('-'), min = ref1[0], max = ref1[1];
        if (value < min || value > max) {
          throw RangeError(pfx + ("is " + value + " (must be " + rule + ")"));
        }
      }
      return value;
    }
    if (type === tv) {
      if (oo.S === tv && rule) {
        if (!RegExp(rule).test(value)) {
          throw RangeError(pfx + ("fails " + rule));
        }
      }
      return value;
    }
    if (/^[A-Z]/.test(type)) {
      if (oo.O === tv) {
        if (eval("value instanceof " + type)) {
          return value;
        }
      }
    }
  }
  throw TypeError(pfx + ("is type " + tv + " not " + types));
};

oo.vObject = function(M, objName, obj) {
  if (oo.O !== oo.type(obj)) {
    throw TypeError(M + objName + (" is type " + (oo.type(obj)) + " not object"));
  }
  return function(signature, fallback) {
    var k, key, len, matches, max, min, ref, ref1, rule, tv, type, types, value;
    matches = signature.match(/^([_a-z][_a-z0-9]*)\s+<([|a-z]+)\s*(.*)>$/i);
    if (!matches) {
      throw RangeError("/nestag/oopish/oo-helpers.litcoffee oo.vObject()\n  signature " + signature + " is invalid");
    }
    signature = matches[0], key = matches[1], types = matches[2], rule = matches[3];
    value = obj[key];
    tv = oo.type(value);
    if (oo.U === tv) {
      if (2 === arguments.length) {
        return fallback;
      }
      throw TypeError(M + objName + '.' + key + " is undefined and has no fallback");
    }
    ref = types.split('|');
    for (k = 0, len = ref.length; k < len; k++) {
      type = ref[k];
      if ((oo.N === type || oo.I === type) && oo.N === tv) {
        if (oo.I === type && value % 1) {
          throw RangeError(M + objName + '.' + key + " is a number but not an integer");
        }
        if (rule) {
          ref1 = rule.split('-'), min = ref1[0], max = ref1[1];
          if (value < min || value > max) {
            throw RangeError(M + objName + '.' + key + (" is " + value + " (must be " + rule + ")"));
          }
        }
        return value;
      }
      if (type === tv) {
        if (oo.S === tv && rule) {
          if (!RegExp(rule).test(value)) {
            throw RangeError(M + objName + '.' + key + (" fails " + rule));
          }
        }
        return value;
      }
      if (/^[A-Z]/.test(type)) {
        if (oo.O === tv) {
          if (eval("value instanceof " + type)) {
            return value;
          }
        }
      }
    }
    throw TypeError(M + objName + '.' + key + (" is type " + tv + " not " + types));
  };
};

Location = (function() {
  Location.prototype.C = 'Location';

  Location.prototype.toString = function() {
    return '[object Location]';
  };

  function Location(config) {
    var M, v;
    if (config == null) {
      config = {};
    }
    M = '/nestag/src/Location.litcoffee Location()\n  ';
    v = oo.vObject(M, 'config', config);
    this.nestag = v('nestag <Nestag>');
    this.coord = v('coord <string>');
    this.cargo = oo.vArray(M + 'config.cargo', config.cargo, '<[any]>', [void 0]);
    this.tags = oo.vArray(M + 'config.tags', config.tags, '<[integer 2-999999]>', []);
    this.ancestors = [];
    this.neighbors = [];
    this.corners = [];
    this.totals = [0, 0];
    if ('Location' === this.C) {
      oo.lock(this);
    }
  }

  Location.prototype.browse = function(config) {
    var M, format, h, nest, tags, v, w;
    if (config == null) {
      config = {};
    }
    M = '/nestag/src/Location.litcoffee Location::browse()\n  ';
    v = oo.vObject(M, 'config', config);
    format = v('format <string ^text|array$>', 'text');
    tags = oo.vArray(M + 'config.tags', config.tags, "<[integer 2-999999]>", []);
    nest = v('nest <integer 0-999999>', 3);
    w = v('w <integer 0-999999>', 79);
    h = v('h <integer 0-999999>', 24);
    if (!this.totals[1]) {
      if ('array' === format) {
        return [this.coord, [], []];
      } else {
        return drawBox(w, h, this.coord, this.cargo).join('\n');
      }
    }
  };

  return Location;

})();

oo.lock(Location);

drawBorder = function(w, h) {
  var M, body, foot, head, i, line;
  M = '/Nestag/src/Location.litcoffee drawBorder()\n  ';
  if (!h) {
    return [];
  }
  if (!w) {
    return Array(h + 1).join('x').split('x');
  }
  if (1 === h) {
    return [oo.rpad('', w)];
  }
  if (1 === w) {
    return Array(h + 1).join(' ').split('');
  }
  head = [oo.rpad('.', w - 1, '-') + '.'];
  foot = [oo.rpad("'", w - 1, '=') + "'"];
  if (2 === h) {
    return head.concat(foot);
  }
  line = oo.rpad('|', w - 1) + '|';
  body = (function() {
    var k, ref, results;
    results = [];
    for (i = k = 0, ref = h - 3; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
      results.push(line);
    }
    return results;
  })();
  return head.concat(body, foot);
};

drawBox = function(w, h, coord, cargo) {
  var M, box, i, item, j, k, key, len, len1, line, lut, m, max, o, pos, ref, ref1, summary, value;
  M = '/Nestag/src/Location.litcoffee drawBox()\n  ';
  box = drawBorder(w, h);
  if (!h || !w) {
    return box;
  }
  if (w < coord.length) {
    coord = coord.substr(coord.length - w);
    pos = 0;
  } else {
    pos = Math.ceil(w / 2 - coord.length / 2);
  }
  box[0] = oo.insert(box[0], coord, pos);
  if (h > 3 && w > 16) {
    summary = [];
    lut = {};
    max = 1;
    for (k = 0, len = cargo.length; k < len; k++) {
      value = cargo[k];
      key = null === value ? 'x' : oo.type(value).charAt(0);
      if ('o' === key && value.C) {
        key = value.C.charAt(0);
      }
      item = lut[key];
      if (item) {
        item.tally++;
        max = Math.max(item.tally.toString().length);
      } else {
        summary.push(lut[key] = {
          key: key,
          tally: 1
        });
      }
    }
    line = 1;
    for (i = m = 0, len1 = summary.length; m < len1; i = ++m) {
      item = summary[i];
      box[line] = oo.insert(box[line], item.key + oo.lpad(item.tally + '', max) + ':', 1);
      line++;
      if (h === line + 2 && summary[i + 1] && summary.length !== h - 2) {
        box[line] = oo.insert(box[line], oo.lpad('', max + 1, '.'), 1);
        line++;
        break;
      }
    }
    box[0] = oo.insert(box[0], '.', max + 2);
    for (j = o = ref = line, ref1 = h - 2; ref <= ref1 ? o <= ref1 : o >= ref1; j = ref <= ref1 ? ++o : --o) {
      box[j] = oo.insert(box[j], ':', max + 2);
    }
    box[h - 1] = oo.insert(box[h - 1], "'", max + 2);
  }
  return box;
};

Nestag = (function() {
  Nestag.prototype.C = 'Nestag';

  Nestag.prototype.toString = function() {
    return '[object Nestag]';
  };

  function Nestag(config) {
    var M, v;
    if (config == null) {
      config = {};
    }
    M = '/nestag/src/Nestag.litcoffee Nestag()\n  ';
    v = oo.vObject(M, 'config', config);
    this.grid = oo.vArray(M + 'config.grid', config.grid, '<[integer 0-999999]1-99>', [2, 2]);
    this.nest = v('nest <integer 0-999999>', 9999);
    this.scheme = v('scheme <string ^continuous|dimensional$>', 'continuous');
    this.form = v('form <string ^short|long$>', 'short');
    oo.define(this, oo._, {}, 'private');
    this[oo._]._locations = {};
    this[oo._]._totalLocations = 0;
    if ('Nestag' === this.C) {
      oo.lock(this.grid);
      oo.lock(this);
    }
  }

  Nestag.prototype.browse = function(config) {
    var M, coord, location, v;
    if (config == null) {
      config = {};
    }
    M = '/nestag/src/Nestag.litcoffee Nestag::browse()\n  ';
    v = oo.vObject(M, 'config', config);
    coord = v("coord <string " + COORD_RULE + ">", '');
    location = this[oo._]._locations[coord];
    if (!location) {
      throw RangeError(M + ("coord '" + coord + "' does not exist"));
    }
    return location.browse(config);
  };

  Nestag.prototype.add = function(config) {
    var M, cargo, coord, location, tags, v;
    if (config == null) {
      config = {};
    }
    M = '/nestag/src/Nestag.litcoffee Nestag::add()\n  ';
    v = oo.vObject(M, 'config', config);
    coord = v("coord <string " + COORD_RULE + ">", '');
    cargo = oo.vArray(M + 'config.cargo', config.cargo, "<[any]>", [void 0]);
    tags = oo.vArray(M + 'config.tags', config.tags, "<[string " + TAG_RULE + "]>", []);
    location = this[oo._]._locations[coord];
    if (location) {
      location.add({
        cargo: cargo
      });
    } else {
      location = new Location({
        nestag: this,
        coord: coord,
        cargo: cargo
      });
      this[oo._]._locations[coord] = location;
      this[oo._]._totalLocations++;
    }
    return coord;
  };

  return Nestag;

})();

global_tags = ['strict', 'skip'];

global_tags.strict = 0;

global_tags.skip = 1;

TAG_RULE = '^[a-z]\\w{1,23}$';

COORD_RULE = '^[a-z]{0,9999}$';

oo.lock(Nestag);

if (oo.F === typeof define && define.amd) {
  define(function() {
    return Nestag;
  });
} else if (oo.O === typeof module && module && module.exports) {
  module.exports = Nestag;
} else {
  oo.G.Nestag = Nestag;
}
}).call(this,this);
